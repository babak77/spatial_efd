

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>spatial_efd.spatial_efd &mdash; Spatial EFD 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Spatial EFD 0.1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Spatial EFD
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <!-- Local TOC -->
                <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Spatial EFD</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>spatial_efd.spatial_efd</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for spatial_efd.spatial_efd</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">shapefile</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Agg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<div class="viewcode-block" id="RotateContour"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.RotateContour">[docs]</a><span class="k">def</span> <span class="nf">RotateContour</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">centroid</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Rotates a contour about a point by a given amount expressed in degrees.</span>

<span class="sd">    Operates by calling rotatePoint() on each x,y pair in turn. X and Y must</span>
<span class="sd">    have the same dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        Y (list): A list (or numpy array) of y coordinate values.</span>
<span class="sd">        rotation (float): The angle in degrees for the contour to be rotated by.</span>
<span class="sd">        centroid (tuple): A tuple containing the x,y coordinates of the centroid</span>
<span class="sd">        to rotate the contour about.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing a list of x coordinates and a list of y</span>
<span class="sd">        coordinates.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">rxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span> <span class="o">=</span> <span class="n">rotatePoint</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">rotation</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">)</span>
        <span class="n">rxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span>
        <span class="n">rys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ry</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rxs</span><span class="p">,</span> <span class="n">rys</span></div>


<div class="viewcode-block" id="NormContour"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.NormContour">[docs]</a><span class="k">def</span> <span class="nf">NormContour</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">rawCentroid</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Normalize the coordinates which make up a contour.</span>

<span class="sd">    Rescale the coordinates to values between 0 and 1 in both the x and y</span>
<span class="sd">    directions. The normalizing is performed using x or y width of the minimum</span>
<span class="sd">    bounding rectangle of the contour, whichever is largest. X and Y must have</span>
<span class="sd">    the same dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        Y (list): A list (or numpy array) of y coordinate values.</span>
<span class="sd">        rawCentroid (tuple): A tuple containing the x,y coordinates of the</span>
<span class="sd">        centroid of the contour</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing a list of normalized x coordinates, a list of</span>
<span class="sd">        normalized y coordinate and the normalized centroid.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># find longest axis of rotated shape</span>
    <span class="n">xwidth</span><span class="p">,</span> <span class="n">ywidth</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="n">getBBoxDimensions</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xwidth</span> <span class="o">&gt;</span> <span class="n">ywidth</span><span class="p">):</span>
        <span class="n">normshape</span> <span class="o">=</span> <span class="n">xwidth</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">ywidth</span> <span class="o">&gt;=</span> <span class="n">xwidth</span><span class="p">):</span>
        <span class="n">normshape</span> <span class="o">=</span> <span class="n">ywidth</span>

    <span class="n">norm_x</span> <span class="o">=</span> <span class="p">[(</span><span class="n">value</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">normshape</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>
    <span class="n">norm_y</span> <span class="o">=</span> <span class="p">[(</span><span class="n">value</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">normshape</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">]</span>

    <span class="n">centroid</span> <span class="o">=</span> <span class="p">((</span><span class="n">rawCentroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">normshape</span><span class="p">,</span>
                <span class="p">(</span><span class="n">rawCentroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">normshape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">norm_x</span><span class="p">,</span> <span class="n">norm_y</span><span class="p">,</span> <span class="n">centroid</span></div>


<div class="viewcode-block" id="CloseContour"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.CloseContour">[docs]</a><span class="k">def</span> <span class="nf">CloseContour</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Close an opened polygon.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        Y (list): A list (or numpy array) of y coordinate values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the X and Y lists of coordinates where the</span>
<span class="sd">        first and last elements are equal.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">+</span> <span class="p">[</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span></div>


<div class="viewcode-block" id="ContourArea"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.ContourArea">[docs]</a><span class="k">def</span> <span class="nf">ContourArea</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the area of an irregular polygon.</span>

<span class="sd">    Ensures the contour is closed before processing, but does not modify</span>
<span class="sd">    X or Y outside the scope of this method. Algorithm taken from</span>
<span class="sd">    http://paulbourke.net/geometry/polygonmesh/.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        Y (list): A list (or numpy array) of y coordinate values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The area of the input polygon.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Check the contour provided is closed</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">CloseContour</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

    <span class="n">Sum</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">Sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">Sum</span><span class="p">)</span></div>


<div class="viewcode-block" id="ContourCentroid"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.ContourCentroid">[docs]</a><span class="k">def</span> <span class="nf">ContourCentroid</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the centroid of an irregular polygon.</span>

<span class="sd">    Ensures the contour is closed before processing, but does not modify</span>
<span class="sd">    X or Y outside the scope of this method. Algorithm taken from</span>
<span class="sd">    http://paulbourke.net/geometry/polygonmesh/.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        Y (list): A list (or numpy array) of y coordinate values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the (x,y) coordinate of the center of the</span>
<span class="sd">        input polygon.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Check the contour provided is closed</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">CloseContour</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

    <span class="n">Area</span> <span class="o">=</span> <span class="n">ContourArea</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>

    <span class="n">Cx</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">Cy</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">const</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">Cx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">const</span>
        <span class="n">Cy</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">const</span>

    <span class="n">AreaFactor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mf">6.</span> <span class="o">*</span> <span class="n">Area</span><span class="p">))</span>

    <span class="n">Cx</span> <span class="o">*=</span> <span class="n">AreaFactor</span>
    <span class="n">Cy</span> <span class="o">*=</span> <span class="n">AreaFactor</span>

    <span class="k">return</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Cx</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Cy</span><span class="p">))</span></div>


<div class="viewcode-block" id="CalculateEFD"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.CalculateEFD">[docs]</a><span class="k">def</span> <span class="nf">CalculateEFD</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">harmonics</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the Elliptical Fourier Descriptors for a polygon.</span>

<span class="sd">    Implements Kuhl and Giardina method of computing the coefficients</span>
<span class="sd">    An, Bn, Cn, Dn for a specified number of harmonics. This code is adapted</span>
<span class="sd">    from the pyefd module. See the original paper for more detail:</span>

<span class="sd">    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed</span>
<span class="sd">    contour. Computer graphics and image processing, 18(3), 236-258.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        Y (list): A list (or numpy array) of y coordinate values.</span>
<span class="sd">        harmonics (int): The number of harmonics to compute for the given shape,</span>
<span class="sd">        defaults to 10.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A numpy array of shape (harmonics, 4) representing the</span>
<span class="sd">        four coefficients for each harmonic computed.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)])</span>

    <span class="n">dxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dxy</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([([</span><span class="mf">0.</span><span class="p">,</span> <span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dt</span><span class="p">)])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">T</span>

    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">harmonics</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">harmonics</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">const</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">phi_n</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">d_cos_phi_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_n</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">d_sin_phi_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_n</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_n</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">a_n</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_cos_phi_n</span><span class="p">)</span>
        <span class="n">b_n</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_sin_phi_n</span><span class="p">)</span>
        <span class="n">c_n</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_cos_phi_n</span><span class="p">)</span>
        <span class="n">d_n</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_sin_phi_n</span><span class="p">)</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">a_n</span><span class="p">,</span> <span class="n">b_n</span><span class="p">,</span> <span class="n">c_n</span><span class="p">,</span> <span class="n">d_n</span>

    <span class="k">return</span> <span class="n">coeffs</span></div>


<div class="viewcode-block" id="inverse_transform"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.inverse_transform">[docs]</a><span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">locus</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">n</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">harmonic</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform an inverse fourier transform to convert the coefficients back into</span>
<span class="sd">    spatial coordinates.</span>

<span class="sd">    Implements Kuhl and Giardina method of computing the performing the</span>
<span class="sd">    transform for a specified number of harmonics. This code is adapted</span>
<span class="sd">    from the pyefd module. See the original paper for more detail:</span>

<span class="sd">    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed</span>
<span class="sd">    contour. Computer graphics and image processing, 18(3), 236-258.</span>

<span class="sd">    Args:</span>
<span class="sd">        coeffs (numpy.ndarray): A numpy array of shape (n, 4) representing the</span>
<span class="sd">        four coefficients for each harmonic computed.</span>
<span class="sd">        locus (tuple): The x,y coordinates of the centroid of the contour being</span>
<span class="sd">        generated. Use calculate_dc_coefficients() to generate the correct locus</span>
<span class="sd">        for a shape.</span>
<span class="sd">        n (int): The number of coordinate pairs to compute. A larger value will</span>
<span class="sd">        result in a more complex shape at the expense of increased computational</span>
<span class="sd">        time. Defaults to 300.</span>
<span class="sd">        harmonics (int): The number of harmonics to be used to generate</span>
<span class="sd">        coordinates, defaults to 10. Must be &lt;= coeffs.shape[0]. Supply a</span>
<span class="sd">        smaller value to produce coordinates for a more generalized shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A numpy array of shape (harmonics, 4) representing the</span>
<span class="sd">        four coefficients for each harmonic computed.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">xt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span> <span class="o">*</span> <span class="n">locus</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">yt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span> <span class="o">*</span> <span class="n">locus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">harmonic</span><span class="p">):</span>

        <span class="n">xt</span> <span class="o">+=</span> <span class="p">((</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span> <span class="o">+</span>
               <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">)))</span>

        <span class="n">yt</span> <span class="o">+=</span> <span class="p">((</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span> <span class="o">+</span>
               <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">harmonic</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span></div>


<div class="viewcode-block" id="InitPlot"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.InitPlot">[docs]</a><span class="k">def</span> <span class="nf">InitPlot</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Set up the axes for plotting, ensuring that x and y dimensions are equal.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ax (matplotlib.axes.Axes): Matplotlib axis instance.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="PlotEllipse"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.PlotEllipse">[docs]</a><span class="k">def</span> <span class="nf">PlotEllipse</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots an ellipse represented as a series of x and y coordinates on a given</span>
<span class="sd">    axis.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax (matplotlib.axes.Axes): Matplotlib axis instance.</span>
<span class="sd">        x (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        y (list): A list (or numpy array) of y coordinate values.</span>
<span class="sd">        color (string): A matplotlib color string to color the line used to</span>
<span class="sd">        plot the ellipse. Defaults to k (black).</span>
<span class="sd">        width (float): The width of the plotted line. Defaults to 1.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">width</span><span class="p">)</span></div>


<div class="viewcode-block" id="SavePlot"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.SavePlot">[docs]</a><span class="k">def</span> <span class="nf">SavePlot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">harmonic</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">figformat</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper around the savefig method.</span>

<span class="sd">    Call this method to add a title identifying the harmonic being plotted, and</span>
<span class="sd">    save the plot to a file. Note that harmonic is simply an int value to be</span>
<span class="sd">    appended to the plot title, it does not select a harmonic to plot.</span>

<span class="sd">    The figformat argumet can take any value which matplotlib understands, which</span>
<span class="sd">    varies by system. To see a full list suitable for your matplotlib instance,</span>
<span class="sd">    call plt.gcf().canvas.get_supported_filetypes().</span>

<span class="sd">    Args:</span>
<span class="sd">        ax (matplotlib.axes.Axes): Matplotlib axis instance.</span>
<span class="sd">        harmonic (int): The harmonic which is being plotted.</span>
<span class="sd">        filename (string): A complete path and filename, without an extension,</span>
<span class="sd">        for the saved plot.</span>
<span class="sd">        figformat (string): A string denoting the format to save the figure as.</span>
<span class="sd">        Defaults to png.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Harmonic: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">harmonic</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">_</span><span class="si">{1}</span><span class="s1">.</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">harmonic</span><span class="p">,</span> <span class="n">figformat</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span></div>


<div class="viewcode-block" id="PlotContour"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.PlotContour">[docs]</a><span class="k">def</span> <span class="nf">PlotContour</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">contour</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Plots a contour on a given axis.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax (matplotlib.axes.Axes): Matplotlib axis instance.</span>
<span class="sd">        contour (numpy.ndarray): A numpy array of shape (n, 2) representing the</span>
<span class="sd">        input contour.</span>
<span class="sd">        color (string): A matplotlib color string to color the line used to</span>
<span class="sd">        plot the contour. Defaults to b (blue).</span>
<span class="sd">        width (float): The width of the plotted line. Defaults to 1.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">contour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">contour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">width</span><span class="p">)</span></div>


<div class="viewcode-block" id="AverageCoefficients"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.AverageCoefficients">[docs]</a><span class="k">def</span> <span class="nf">AverageCoefficients</span><span class="p">(</span><span class="n">coeffList</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Average the coefficients contained in the list of coefficient arrays,</span>
<span class="sd">    coeffList.</span>

<span class="sd">    This method is outlined in:</span>

<span class="sd">    2-D particle shape averaging and comparison using Fourier descriptors:</span>
<span class="sd">    Powder Technology Volume 104, Issue 2, 1 September 1999, Pages 180-189</span>

<span class="sd">    Args:</span>
<span class="sd">        coeffList (list): A list of coefficient arrays to be averaged.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A numpy array containing the average An, Bn, Cn, Dn</span>
<span class="sd">        coefficient values.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">nHarmonics</span> <span class="o">=</span> <span class="n">coeffList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coeffsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nHarmonics</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">coeffList</span><span class="p">:</span>
        <span class="n">coeffsum</span> <span class="o">+=</span> <span class="n">coeff</span>

    <span class="n">coeffsum</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffList</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">coeffsum</span></div>


<div class="viewcode-block" id="AverageSD"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.AverageSD">[docs]</a><span class="k">def</span> <span class="nf">AverageSD</span><span class="p">(</span><span class="n">coeffList</span><span class="p">,</span> <span class="n">avgcoeffs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Use the coefficients contained in the list of coefficient arrays,</span>
<span class="sd">    coeffList, and the average coefficient values to compute the standard</span>
<span class="sd">    deviation of series of ellipses.</span>

<span class="sd">    This method is outlined in:</span>

<span class="sd">    2-D particle shape averaging and comparison using Fourier descriptors:</span>
<span class="sd">    Powder Technology Volume 104, Issue 2, 1 September 1999, Pages 180-189</span>

<span class="sd">    Args:</span>
<span class="sd">        coeffList (list): A list of coefficient arrays to be averaged.</span>
<span class="sd">        avgcoeffs (numpy.ndarray): A numpy array containing the average</span>
<span class="sd">        coefficient values, generated by calling AverageCoefficients().</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A numpy array containing the standard deviation</span>
<span class="sd">        An, Bn, Cn, Dn coefficient values.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nHarmonics</span> <span class="o">=</span> <span class="n">avgcoeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coeffsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nHarmonics</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">coeffList</span><span class="p">:</span>
        <span class="n">coeffsum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">coeffsum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">avgcoeffs</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span></div>


<div class="viewcode-block" id="Nyquist"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.Nyquist">[docs]</a><span class="k">def</span> <span class="nf">Nyquist</span><span class="p">(</span><span class="n">contour</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the maximum number of harmonics that can be computed for a given</span>
<span class="sd">    contour, the nyquist freqency.</span>

<span class="sd">    See this paper for details:</span>
<span class="sd">    C. Costa et al. / Postharvest Biology and Technology 54 (2009) 38-47</span>

<span class="sd">    Args:</span>
<span class="sd">        contour (numpy.ndarray): A numpy array of shape (n, 2) representing the</span>
<span class="sd">        input contour.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The nyquist frequency, expressed as a number of harmonics.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="FourierPower"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.FourierPower">[docs]</a><span class="k">def</span> <span class="nf">FourierPower</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">contour</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.9999</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the total Fourier power and find the minium number of harmonics</span>
<span class="sd">    required to exceed the threshold fraction of the total power.</span>

<span class="sd">    This is a good method for identifying the number of harmonics to use to</span>
<span class="sd">    describe a polygon. For more details see:</span>

<span class="sd">    C. Costa et al. / Postharvest Biology and Technology 54 (2009) 38-47</span>

<span class="sd">    Warning:</span>
<span class="sd">        The number of coeffs must be &gt;= the nyquist freqency.</span>

<span class="sd">    Args:</span>
<span class="sd">        coeffs (numpy.ndarray): A numpy array of shape (n, 4) representing the</span>
<span class="sd">        four coefficients for each harmonic computed.</span>
<span class="sd">        contour (numpy.ndarray): A numpy array of shape (n, 2) representing the</span>
<span class="sd">        input contour.</span>
<span class="sd">        threshold (float): The threshold fraction of the total Fourier power.</span>
<span class="sd">        Default is 0.9999.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The number of harmonics required to represent the contour above the</span>
<span class="sd">        threshold Fourier power.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nyquist</span> <span class="o">=</span> <span class="n">Nyquist</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>

    <span class="n">totalPower</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">currentPower</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nyquist</span><span class="p">):</span>
            <span class="n">totalPower</span> <span class="o">+=</span> <span class="p">((</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span>
                           <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nyquist</span><span class="p">):</span>
        <span class="n">currentPower</span> <span class="o">+=</span> <span class="p">((</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span>
                         <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">currentPower</span> <span class="o">/</span> <span class="n">totalPower</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="normalize_efd"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.normalize_efd">[docs]</a><span class="k">def</span> <span class="nf">normalize_efd</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">size_invariant</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Normalize the Elliptical Fourier Descriptor coefficients for a polygon.</span>

<span class="sd">    Implements Kuhl and Giardina method of normalizing the coefficients</span>
<span class="sd">    An, Bn, Cn, Dn. Performs 3 separate normalizations. First, it makes the data</span>
<span class="sd">    location invariant by re-scaling the data to a common origin. Secondly, the</span>
<span class="sd">    data is rotated with respect to the major axis. Thirdly, the coefficients</span>
<span class="sd">    are normalized with regard to the absolute value of A_1. This code is</span>
<span class="sd">    adapted from the pyefd module. See the original paper for more detail:</span>

<span class="sd">    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed</span>
<span class="sd">    contour. Computer graphics and image processing, 18(3), 236-258.</span>

<span class="sd">    Args:</span>
<span class="sd">        coeffs (numpy.ndarray): A numpy array of shape (n, 4) representing the</span>
<span class="sd">        four coefficients for each harmonic computed.</span>
<span class="sd">        size_invariant (bool): Set to True (the default) to perform the third</span>
<span class="sd">        normalization and false to return the data withot this processing step.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A numpy array of shape (harmonics, 4) representing the</span>
<span class="sd">        four coefficients for each harmonic computed.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Make the coefficients have a zero phase shift from</span>
    <span class="c1"># the first major axis. Theta_1 is that shift angle.</span>
    <span class="n">theta_1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">((</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
               <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])),</span>
              <span class="p">((</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">-</span>
               <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">+</span>
               <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">-</span>
               <span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">))))</span>

    <span class="c1"># Rotate all coefficients by theta_1.</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                                                      <span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]]),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">theta_1</span><span class="p">),</span>
                                           <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">theta_1</span><span class="p">)],</span>
                                           <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">theta_1</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">theta_1</span><span class="p">)]]))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Make the coefficients rotation invariant by rotating so that</span>
    <span class="c1"># the semi-major axis is parallel to the x-axis.</span>
    <span class="n">psi_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">psi_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi_1</span><span class="p">)],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi_1</span><span class="p">)]])</span>

    <span class="c1"># Rotate all coefficients by -psi_1.</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">psi_r</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                     <span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                                                         <span class="n">coeffs</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                                <span class="mi">3</span><span class="p">]]]))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">size_invariant</span><span class="p">:</span>
        <span class="c1"># Obtain size-invariance by normalizing.</span>
        <span class="n">coeffs</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">coeffs</span></div>


<div class="viewcode-block" id="calculate_dc_coefficients"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.calculate_dc_coefficients">[docs]</a><span class="k">def</span> <span class="nf">calculate_dc_coefficients</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the dc coefficients, used as the locus when calling</span>
<span class="sd">    inverse_transform().</span>

<span class="sd">    This code is adapted from the pyefd module. See the original paper for</span>
<span class="sd">    more detail:</span>

<span class="sd">    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed</span>
<span class="sd">    contour. Computer graphics and image processing, 18(3), 236-258.</span>

<span class="sd">    Args:</span>
<span class="sd">        X (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        Y (list): A list (or numpy array) of y coordinate values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the c and d coefficients.</span>

<span class="sd">    Todo: Test this against other efd modules to check that the x,y to y,x</span>
<span class="sd">    conversion is correct.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)])</span>

    <span class="n">dxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dxy</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([([</span><span class="mf">0.</span><span class="p">,</span> <span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dt</span><span class="p">)])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">A0</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">dt</span><span class="p">))</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span> <span class="o">+</span> <span class="n">xi</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">dxy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">dt</span><span class="p">))</span> <span class="o">*</span> <span class="n">diff</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>

    <span class="c1"># A0 and CO relate to the first point of the contour array as origin.</span>
    <span class="c1"># Adding those values to the coefficients to make them relate to true origin</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">contour</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A0</span><span class="p">,</span> <span class="n">contour</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">C0</span><span class="p">)</span></div>


<div class="viewcode-block" id="LoadGeometries"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.LoadGeometries">[docs]</a><span class="k">def</span> <span class="nf">LoadGeometries</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Takes a filename and uses pyshp to load it, returning a list of</span>
<span class="sd">    shapefile.ShapeRecord instances.</span>

<span class="sd">    This list can be iterated over, passing the individual shape instances</span>
<span class="sd">    to ProcessGeometry() one by one. There is no input handling if a non-polygon</span>
<span class="sd">    shapefile is passed in, that will result in undefined behavior.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename (string): A filename with optional full path pointing to an</span>
<span class="sd">        ESRI shapefile to be loaded by the pyshp module. The file extension is</span>
<span class="sd">        optional.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of shapefile._ShapeRecord objects representing each polygon</span>
<span class="sd">        geometry in the shapefile.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">shp</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shp</span><span class="o">.</span><span class="n">shapeRecords</span><span class="p">()</span></div>


<div class="viewcode-block" id="ProcessGeometry"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.ProcessGeometry">[docs]</a><span class="k">def</span> <span class="nf">ProcessGeometry</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to handle all the geometry conversion that may be needed by the rest</span>
<span class="sd">    of the EFD code.</span>

<span class="sd">    Method which takes a single shape instance from a shapefile</span>
<span class="sd">    eg shp.Reader(&#39;shapefile.shp&#39;).shapeRecords()[n]</span>
<span class="sd">    where n is the index of the shape within a multipart geometry. This results</span>
<span class="sd">    in the contour, coordinate list and centroid data computed for the input</span>
<span class="sd">    polygon being normalized and returned to the user.</span>

<span class="sd">    Args:</span>
<span class="sd">        shapefile._ShapeRecord: A shapefile object representing the geometry and</span>
<span class="sd">        attributes of a single polygon from a multipart shapefile.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing a list of normalized x coordinates, a list of</span>
<span class="sd">        normalized y coordinates, contour (a list of [x,y] coordinate pairs,</span>
<span class="sd">        normalized about the shape&#39;s centroid) and the normalized coordinate</span>
<span class="sd">        centroid.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">centroid</span> <span class="o">=</span> <span class="n">ContourCentroid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">NormCentroid</span> <span class="o">=</span> <span class="n">NormContour</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>

    <span class="n">contour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">contour</span><span class="p">,</span> <span class="n">NormCentroid</span></div>


<div class="viewcode-block" id="rotatePoint"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.rotatePoint">[docs]</a><span class="k">def</span> <span class="nf">rotatePoint</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">centerPoint</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Rotates a point counter-clockwise around centerPoint.</span>

<span class="sd">    The angle to rotate by is supplied in degrees. Code based on:</span>
<span class="sd">    https://gist.github.com/somada141/d81a05f172bb2df26a2c</span>

<span class="sd">    Args:</span>
<span class="sd">        point (tuple): The point to be rotated, represented as an (x,y) tuple.</span>
<span class="sd">        centerPoint (tuple): The point to be rotated about, represented as an</span>
<span class="sd">        (x,y) tuple.</span>
<span class="sd">        angle (float): The angle to rotate point by, in the counter-clockwise</span>
<span class="sd">        direction.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple representing the rotated point, (x,y).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">temp_point</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">centerPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">centerPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">temp_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">-</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">temp_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>

    <span class="n">temp_point</span> <span class="o">=</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">centerPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">centerPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="getBBoxDimensions"><a class="viewcode-back" href="../../spatial_efd.html#spatial_efd.spatial_efd.getBBoxDimensions">[docs]</a><span class="k">def</span> <span class="nf">getBBoxDimensions</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the width in the x and y dimensions and the maximum x and y</span>
<span class="sd">    coordinates for the bounding box of a given list of x and y coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (list): A list (or numpy array) of x coordinate values.</span>
<span class="sd">        y (list): A list (or numpy array) of y coordinate values.</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: A four-tuple representing (width in the x direction, width in the</span>
<span class="sd">        y direction, the minimum x coordinate and the minimum y coordinate).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

    <span class="n">xmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Stuart W.D. Grieve.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
   

</body>
</html>